// src/lib/utils/serializationHelpers.ts
/**
 * Utility functions for serializing collections & deep-cloning objects.
 *
 * These helpers are framework-agnostic and can be used in various scenarios
 * requiring robust serialization or cloning. Zustand-persist is one common
 * use case, but they are not limited to it. They aim to handle Map serialization
 * and provide a safe deep clone mechanism, playing nicely with constraints like
 * JSON compatibility and payload size limits (e.g., for Supabase).
 *
 * @module serializationHelpers
 */

/* ------------------------------------------------------------------ */
/* Type Definitions                                                   */
/* ------------------------------------------------------------------ */

/**
 * Represents the serialized format of a Map, specifically a tuple array [K, V][],
 * which is suitable for direct use with JSON.stringify.
 */
export type SerializedMap<K extends string | number, V> = [K, V][];

/* ------------------------------------------------------------------ */
/* Map <‑‑> JSON helpers                                              */
/* ------------------------------------------------------------------ */

/**
 * Converts a Map to a JSON–serializable tuple array `SerializedMap<K, V>`.
 *
 * Keys that are not `string | number` will be stringified by `JSON.stringify`
 * when the resulting array is serialized (e.g., `Symbol('x')` becomes `'Symbol(x)'`,
 * object keys become `'[object Object]'`), and may not deserialize correctly
 * back into the original key type with `jsonToMap`. Only `string` and `number`
 * keys are guaranteed to round-trip correctly.
 *
 * In development environments (`process.env.NODE_ENV === 'development'`), this
 * function issues a console warning *once* if non-string/number keys are detected
 * during conversion, as this indicates potential data loss or unexpected behavior
 * after serialization. For stricter validation, consider pre-validating keys
 * before calling this function. A future version might include an optional strict mode.
 *
 * @param map - The Map to convert. Assumes keys should ideally be string | number.
 * @returns A `SerializedMap<K, V>` array of [key, value] tuples.
 */
export function mapToJson<K extends string | number, V>(map: Map<K, V>): SerializedMap<K, V> {
  // Runtime check for non-primitive keys (only in development to avoid prod overhead)
  if (process.env.NODE_ENV === 'development' && map.size > 0) {
    let warnedAboutKeyType = false; // Flag to prevent log flooding
    for (const key of map.keys()) {
      const keyType = typeof key;
      if (keyType !== 'string' && keyType !== 'number') {
        if (!warnedAboutKeyType) {
          console.warn(
            `mapToJson: Detected key of type '${keyType}' (value: ${String(key)}). ` +
            `Only 'string' or 'number' keys are guaranteed to round-trip correctly through JSON serialization. ` +
            `This key may be stringified inconsistently or lost. Further warnings for this map instance will be suppressed.`
          );
          warnedAboutKeyType = true; // Suppress further warnings for this call
        }
        // If performance is critical even in dev, could potentially break here
        // break;
      }
    }
  }

  // Spreading entries is a concise way to get the array [[k1, v1], [k2, v2], ...]
  return [...map.entries()];
}

/**
 * Re‑hydrates a Map from a `SerializedMap<K, V>` tuple array, typically obtained
 * after using `JSON.parse` on data previously generated by `mapToJson` and
 * `JSON.stringify`.
 *
 * Assumes keys in the input array are already of the desired type `K`
 * (typically `string` or `number` after JSON parsing).
 *
 * Note: This function does not recursively revive nested Maps or Sets within
 * the map's values. If deep revival of nested collections is needed, use
 * `deepClone` on the original structure before serialization if possible, or
 * implement a custom revival logic after using `jsonToMap`.
 *
 * @param entries - A `SerializedMap<K, V>` array of [key, value] tuples.
 * @returns A new Map instance populated with the entries.
 */
export function jsonToMap<K extends string | number, V>(entries: SerializedMap<K, V>): Map<K, V> {
  // The Map constructor directly accepts an iterable of [key, value] pairs.
  return new Map(entries);
}

/* ------------------------------------------------------------------ */
/* Deep‑clone helper                                                  */
/* ------------------------------------------------------------------ */

/**
 * Creates a deep, structural clone of an object `obj`.
 * Prioritizes using the built-in `structuredClone` API when available.
 * `structuredClone` handles complex types (`Date`, `RegExp`, `Map`, `Set`,
 * `BigInt`, `ArrayBuffer`, `Blob`, etc.), circular references, and preserves
 * prototype chains correctly.
 *
 * **Browser/Runtime Support:** `structuredClone` is available in most modern
 * environments (Node.js >= 17+, Chrome/Edge >= 98, Firefox >= 94, Safari >= 15.4).
 * See full support: https://caniuse.com/structuredclone
 *
 * **Performance:** `structuredClone` is generally significantly faster
 * (e.g., ~2-5x+ vs lodash.cloneDeep in V8 11+) than JSON-based methods or deep
 * recursive copying for large/complex objects. See benchmarks like:
 * https://measurethat.net/Benchmarks/Show/12886/0/deep-clone-structuredclone-vs-lodashclonedeep
 * Always measure in performance-critical paths if needed.
 *
 * **Fallback Strategy:** Falls back to `JSON.stringify`/`parse` only if
 * `structuredClone` is not available or fails. For environments guaranteed
 * to lack `structuredClone` (e.g., older React Native, Jest configurations),
 * consider using a polyfill like `core-js` or the one provided by MDN:
 * https://developer.mozilla.org/en-US/docs/Web/API/structuredClone#polyfill
 *
 * **⚠️ JSON Fallback Caveats:** The `JSON.stringify`/`parse` method silently:
 * - Drops functions and `undefined` properties/values.
 * - Converts `Date` objects to ISO date strings.
 * - Converts `Map`, `Set`, `RegExp` instances to empty objects (`{}`).
 * - Silently drops `ArrayBuffer`, `Blob`, TypedArrays, etc. (become `{}`).
 * - Throws an error on `BigInt` values.
 * - Loses the prototype chain (class instances become plain objects).
 * - Cannot handle circular references (throws an error).
 *
 * Throws the original error if cloning fails using both methods.
 *
 * @param obj - The object or value to clone.
 * @returns A deep clone of `obj`.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/structuredClone - MDN documentation for structuredClone.
 */
export function deepClone<T>(obj: T): T {
  // Check if the modern structuredClone function is globally available.
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore - Suppress TS error if lib definitions don't include structuredClone.
  if (typeof structuredClone === 'function') {
    try {
      // Use the robust and performant structured clone algorithm.
      return structuredClone(obj);
    } catch (e) {
      console.warn("structuredClone failed, attempting fallback to JSON clone:", e);
      // Fall-through to the JSON method below as a last resort.
    }
  }

  // Fallback for environments without structuredClone OR if structuredClone failed.
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (e) {
    console.error("Deep cloning failed using both structuredClone (if available/applicable) and JSON methods.", e);
    // Re-throw the original error to preserve stack trace and context
    throw e;
  }
}

// Ensure POSIX newline at end of file for consistent diffs.